# Class modifiers for API maintainers

Dart 3.0 增加了一些新的修饰符，你可以将它们放在类和mixin声明上。
如果你是一个库包的作者，这些修饰符可以让你更好地控制用户对你的包导出的类型的使用。
这可以让你更容易地演化你的包，并且更容易知道你的代码的更改是否会影响用户。

Dart 3.0 还包括一个重大变更，关于将类用作mixin的使用。
这个变更可能不会破坏*你的*类，但它可能会破坏*用户*的类。

本指南将引导你了解这些变化，以便你知道如何使用新的修饰符，以及它们如何影响你的库的用户。

## The `mixin` modifier on classes

最需要注意的修饰符是 `mixin`。
在 Dart 3.0 之前的语言版本中，任何类都可以用作另一个类的 `with` 子句中的 mixin，_除非_该类：

* 声明了任何非工厂构造函数。
* 继承了除 `Object` 之外的任何类。

这使得很容易在不知情的情况下，通过向类添加构造函数或 `extends` 子句来意外地破坏别人的代码。

Dart 3.0 默认不再允许类用作 mixin。
相反，你必须通过声明 `mixin class` 显式地选择这种行为：

```dart
mixin class Both {}

class UseAsMixin with Both {}
class UseAsSuperclass extends Both {}
```

如果你将你的包更新到 Dart 3.0 并且不更改任何代码，你可能不会看到任何错误。
但如果用户使用你的类作为 mixin，你可能会无意中破坏他们的代码。

### 迁移类作为 mixin

如果类具有非工厂构造函数、`extends` 子句或 `with` 子句，那么它本来就不能用作 mixin。
在 Dart 3.0 中行为不会改变；
你无需担心，也无需做任何事情。

实际上，这描述了大约 90% 的现有类。
对于剩下的可以用作 mixin 的类，你需要决定你想支持什么。

以下是一些帮助你决定的问题。第一个是务实的：

* **你想冒着破坏任何用户的风险吗？** 如果答案是明确的“否”，
  那么在任何可能用作 mixin 的类之前添加 `mixin`。
  这将完全保留你的 API 的现有行为。

另一方面，如果你想借此机会重新考虑你的 API 提供的功能，那么你可能*不*希望将其变成 `mixin class`。考虑以下两个设计问题：

* **你希望用户能够直接构造它的实例吗？**
  换句话说，这个类是否故意不抽象？

* **你*希望*人们能够使用这个声明作为 mixin 吗？**
  换句话说，你希望他们能够在 `with` 子句中使用它吗？

如果这两个问题的答案都是“是”，那么将其设为 mixin class。如果第二个问题的答案是“否”，那么只需将其保留为类。如果第一个问题的答案是“否”而第二个问题的答案是“是”，那么将其从类改为 mixin 声明。

最后两个选项，即保留为类或将其变为纯 mixin，都是 API 的重大变更。如果你这样做，你将需要提升包的主要版本号。

## 其他选择性修饰符

处理类作为 mixin 是 Dart 3.0 中唯一影响你包的 API 的关键变化。到此为止，如果你不想对你的包允许用户做的事情进行其他更改，你可以停止了。

请注意，如果你继续使用下面描述的任何修饰符，这可能会对你的包的 API 造成重大变更，因而需要提高主要版本号。

## `interface` 修饰符

Dart 没有单独的语法来声明纯接口。
相反，你声明一个只包含抽象方法的抽象类。
当用户在你的包的 API 中看到这个类时，
他们可能不知道这个类是否包含可以通过扩展类来重用的代码，
或者是否仅作为接口使用。

你可以通过在类上添加 `interface` 修饰符来澄清这一点。
这允许类在 `implements` 子句中使用，
但防止它在 `extends` 中使用。

即使类*确实*有非抽象方法，你也可能希望防止用户扩展它。
继承是软件中最强大的耦合类型之一，因为它可以实现代码重用。
但这种耦合也危险且脆弱。
当继承跨越包边界时，很难在不破坏子类的情况下演化超类。

将类标记为 `interface` 允许用户构造它（除非它也被标记为 `abstract`），并实现该类的接口，但防止用户重用其任何代码。

当类被标记为 `interface` 时，该限制在声明类的库内可以被忽略。
在库内，你可以自由地扩展它，因为这都是你的代码，
并且你大概知道自己在做什么。
该限制适用于其他包，
甚至适用于你自己包内的其他库。

## `base` 修饰符

`base` 修饰符在某种程度上与 `interface` 相反。
它允许你在 `extends` 子句中使用类，或在 `with` 子句中使用 mixin 或 mixin 类。
但是，它不允许类所在库之外的代码在 `implements` 子句中使用该类或 mixin。

这确保了每个作为你类或 mixin 接口实例的对象都继承了你的实际实现。
特别是，这意味着每个实例都将包含你类或 mixin 声明的所有私有成员。
这有助于防止可能发生的运行时错误。

考虑以下库：

```dart
// a.dart
class A {
  void _privateMethod() {
    print('I inherited from A');
  }
}

void callPrivateMethod(A a) {
  a._privateMethod();
}
```

这段代码本身看起来没问题，
但没有什么能阻止用户创建另一个像这样的库：

```dart
// b.dart

import 'a.dart';

class B implements A {
  // No implementation of _privateMethod()!
}

main() {
  callPrivateMethod(B()); // Runtime exception!❌
}
```

将 `base` 修饰符添加到类中可以帮助防止这些运行时错误。
与 `interface` 一样，你可以在声明 `base` 类或 mixin 的同一个库中忽略此限制。
这样，同一个库中的子类将被提醒实现私有方法。
但请注意，下一节*确实*适用：

### 基类传递性

将一个类标记为 `base` 的目的是确保每个该类型的实例具体继承自它。
为了维持这一点，基类限制是“传染性”的。
每个标记为 `base` 类型的子类型——*直接或间接*——也必须防止被实现。
这意味着它必须被标记为 `base`（或者 `final` 或 `sealed`，我们将在下一节讨论）。

因此，应用 `base` 到一个类型需要一些谨慎。
它不仅影响用户对你的类或 mixin 的使用，
还影响*他们*的子类可以提供的功能。
一旦你在一个类型上使用 `base`，它下面的整个层次结构都被禁止被实现。

这听起来很严格，但这是大多数其他编程语言一直以来的工作方式。
大多数语言根本没有隐式接口，
所以当你在 Java、C# 或其他语言中声明一个类时，
你实际上受到了同样的约束。

## `final` 修饰符

如果你想要同时具备 `interface` 和 `base` 的所有限制，
可以将类或 mixin 类标记为 `final`。
这将阻止你的库外的任何人创建任何类型的子类型：
不能在 `implements`、`extends`、`with` 或 `on` 子句中使用它。

这对类的用户来说是最严格的限制。
他们唯一能做的就是构造它（除非它被标记为 `abstract`）。
作为类的维护者，你将拥有最少的限制。
你可以添加新方法，将构造函数变成工厂构造函数等，
而不必担心破坏任何下游用户。

## `sealed` 修饰符

最后一个修饰符 `sealed` 是特殊的。
它主要存在是为了在模式匹配中启用穷尽性检查。
如果一个 switch 对于标记为 `sealed` 的类型的每一个直接子类型都有情况，
那么编译器知道这个 switch 是穷尽的。


```dart title="amigos.dart"
sealed class Amigo {}

class Lucky extends Amigo {}

class Dusty extends Amigo {}

class Ned extends Amigo {}

String lastName(Amigo amigo) => switch (amigo) {
      Lucky _ => 'Day',
      Dusty _ => 'Bottoms',
      Ned _ => 'Nederlander',
    };
```

这个 switch 为 `Amigo` 的每个子类型都设置了一个 case。
编译器知道每个 `Amigo` 实例必须是这些子类型之一的实例，因此它知道这个 switch 是安全且穷尽的，不需要任何最终的默认 case。

为了确保这一点，编译器强制执行两项限制：

1. `sealed` 类本身不能直接构造。
   否则，你可能会有一个不是任何子类型实例的 `Amigo` 实例。
   因此，每个 `sealed` 类隐式地也是 `abstract` 的。

2. `sealed` 类型的每个直接子类型必须在声明 `sealed` 类型的同一个库中。
   这样，编译器可以找到所有的子类型。它知道不会有其他隐藏的子类型在外面漂浮，而这些子类型不会匹配任何 case。

第二个限制类似于 `final`。
像 `final` 一样，这意味着标记为 `sealed` 的类不能直接在声明它的库外被扩展、实现或混入。
但是，不像 `base` 和 `final`，它没有*传递*限制：

```dart title="amigo.dart"
// amigo.dart

sealed class Amigo {}
class Lucky extends Amigo {}
class Dusty extends Amigo {}
class Ned extends Amigo {}
```

```dart title="other.dart"
// other.dart

// This is an error:
class Bad extends Amigo {}

// But these are both fine:
class OtherLucky extends Lucky {}
class OtherDusty implements Dusty {}
```

当然，如果你*希望*你的 `sealed` 类型的子类型也受到限制，
你可以通过使用 `interface`、`base`、`final` 或 `sealed` 来标记它们。

### `sealed` 与 `final`

如果你有一个类不希望用户能够直接子类化，那么何时应该使用 `sealed` 而不是 `final`？有几个简单的规则：

* 如果你希望用户能够直接构造类的实例，那么它*不能*使用 `sealed`，因为 `sealed` 类型隐式是抽象的。

* 如果你的库中没有该类的子类型，那么使用 `sealed` 没有意义，因为你不会得到穷尽性检查的好处。

否则，如果类确实有一些你定义的子类型，那么 `sealed` 可能就是你想要的。
如果用户看到该类有一些子类型，那么能够在 switch 语句中分别处理每个子类型是很方便的，并且编译器会知道整个类型都被覆盖了。

使用 `sealed` 意味着如果你以后在库中添加另一个子类型，这将是一个破坏性的 API 更改。
当出现新子类型时，所有现有的 switch 都会变得不穷尽，因为它们没有处理新类型。
这就像向枚举中添加新值一样。

这些不穷尽的 switch 编译错误对用户来说是*有用的*，因为它们引起用户注意代码中的需要处理新类型的地方。

但这也意味着每当你添加新子类型时，这都是一个破坏性的更改。
如果你希望能够以非破坏性的方式添加新子类型，那么最好使用 `final` 标记超类型而不是 `sealed`。
这意味着当用户对该超类型的值进行 switch 时，即使他们处理了所有子类型，编译器也会强制他们添加另一个默认情况。
如果你以后添加更多子类型，那么就会执行该默认情况。

## 总结

作为一个 API 设计师，这些新的修饰符让你能够控制用户如何使用你的代码，反之，你也能够在不破坏用户代码的情况下演化你的代码。

但这些选项也带来了复杂性：作为一个 API 设计师，你现在有更多的选择需要做。此外，由于这些特性是新的，我们仍然不知道最佳实践是什么。每种语言的生态系统都是不同的，并且有不同的需求。

幸运的是，你不需要一次性全部弄明白。我们有意选择了默认值，即使你什么都不做，你的类大多仍具有它们在 3.0 之前的相同功能。如果你只是想保持你的 API 原样，只需在已经支持的类上添加 `mixin`，就完成了。

随着时间的推移，当你想要更细致的控制时，可以考虑应用一些其他的修饰符：

* 使用 `interface` 来防止用户重用你的类的代码，同时允许他们重新实现其接口。

* 使用 `base` 来要求用户重用你的类的代码，并确保你的类类型的每个实例都是该实际类或其子类的实例。

* 使用 `final` 来完全防止类被扩展。

* 使用 `sealed` 来对一系列子类型进行穷尽性检查。

当你这样做时，在发布你的包时增加主版本号，因为这些修饰符都意味着破坏性的更改。
